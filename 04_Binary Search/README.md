# Binary Search

### 基本概念と主な特徴:
| 項目               | 説明                                                                                     |
|--------------------|------------------------------------------------------------------------------------------|
| **基本概念**       | ソート済みのデータセット（通常は配列やリスト）の中央の要素を調べ、検索対象の値と比較して、検索範囲を狭めながら目的の値を探し出す方法。 |
| **前提条件**       | データセットはソート済みである必要がある。                                                 |
| **時間計算量**     | \(O(\log n)\)                                                                            |
| **空間計算量**     | \(O(1)\) (反復的なアプローチの場合)                                                       |
| **最適な使用ケース** | ソート済みのデータセットで特定の値を高速に検索する場面。                                   |
| **特徴**           | 1. 非常に効率的な検索方法。ソート済みの大きなデータセットに対しては特に有効。               |
|                    | 2. 連続的なデータ構造（配列やリストなど）にのみ適用可能。                                  |
|                    | 3. インデックスが利用可能なデータ構造で最も効果的。                                        |
|                    | 4. キーが見つからない場合でも、キーが挿入されるべき位置を示す情報が得られることがある。      |

# Binary Search典型アルゴリズム
二分探索（またはバイナリサーチ）は、ソート済みのリストや配列で、指定された要素（キー）を効率的に検索するアルゴリズムです。主なアイディアは、中央の要素を確認し、キーが中央の要素より小さいか大きいかに応じて、検索範囲を半分にしていくことです。

以下は、二分探索の典型的なアルゴリズムを示すC++の実装です：

```cpp
#include <vector>

int binarySearch(const std::vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;  // オーバーフローを防ぐための計算方法

        if (nums[mid] == target) {
            return mid;  // キーが見つかった場合のインデックスを返す
        } else if (nums[mid] < target) {
            left = mid + 1;  // キーが中央の要素より大きい場合、左の境界を動かす
        } else {
            right = mid - 1;  // キーが中央の要素より小さい場合、右の境界を動かす
        }
    }

    return -1;  // キーが見つからない場合は-1を返す
}
```

このアルゴリズムの時間計算量は \(O(\log n)\) であり、ソート済みのデータに対して非常に効率的です。