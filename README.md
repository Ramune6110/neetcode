# Data Structure（データ構造）

### シーケンスコンテナ (Sequence Containers):
1. **`std::vector`**:
    - 動的配列。連続したメモリにデータを格納する。要素の追加/削除は末尾が最も高速。
2. **`std::list`**:
    - 二重連結リスト。要素の追加/削除がO(1)で行えるが、ランダムアクセスは遅い。
3. **`std::deque`**:
    - 両端キュー（double-ended queue）。先頭と末尾の両方での要素の追加/削除が高速。
4. **`std::forward_list`** (C++11以降):
    - 単方向連結リスト。
5. **`std::array`** (C++11以降):
    - 固定長の配列。サイズ変更不可。

### アソシアティブコンテナ (Associative Containers):
1. **`std::set`**:
    - ソートされたユニークな要素の集合。要素の追加、削除、検索がバランス木のような構造で高速。
2. **`std::multiset`**:
    - ソートされた要素の集合。重複要素を許容。
3. **`std::map`**:
    - キーと値のペアの集合。キーはユニーク。
4. **`std::multimap`**:
    - キーと値のペアの集合。キーの重複を許容。

### アンオーダードアソシアティブコンテナ (Unordered Associative Containers) (C++11以降):
1. **`std::unordered_set`**:
    - ハッシュセット。ソートされていないユニークな要素の集合。
2. **`std::unordered_multiset`**:
    - ハッシュセット。ソートされていない要素の集合で、重複を許容。
3. **`std::unordered_map`**:
    - ハッシュマップ。ソートされていないキーと値のペアの集合。キーはユニーク。
4. **`std::unordered_multimap`**:
    - ハッシュマップ。ソートされていないキーと値のペアの集合。キーの重複を許容。

### アダプターコンテナ (Container Adapters):
1. **`std::stack`**:
    - LIFO (Last In, First Out) プリンシプルに基づくデータ構造。
2. **`std::queue`**:
    - FIFO (First In, First Out) プリンシプルに基づくデータ構造。
3. **`std::priority_queue`**:
    - 優先度を持つキュー。

## シーケンスコンテナ (Sequence Containers):
# 1. vector

### 基本概念と主な特徴:

| 項目 | 説明 |
|------|------|
| **基本概念** | `vector`は動的配列を表現するコンテナです。要素は連続したメモリ領域に格納されます。 |
| **順序** | 要素は挿入された順序で格納されます。 |
| **可変サイズ** | `vector`はサイズが動的であり、要素の追加や削除によりサイズが変更されます。 |
| **アクセス速度** | インデックスを使った要素へのアクセス（例：`vec[3]`）はO(1)の時間複雑度です。 |
| **挿入/削除速度** | 末尾への要素の挿入や削除は通常O(1)ですが、中央や先頭への挿入や削除はO(n)です。 |
| **メモリ** | 必要に応じてメモリを動的に確保します。予約 (`reserve()`) を使用してメモリの再確保を減少させることができます。 |
| **連続性** | メモリは連続しているため、ポインタやイテレータを使って要素にアクセスできます。 |
| **イテレータの無効化** | メモリの再確保が行われる場合（例：`push_back()`によるサイズの拡張時）、イテレータは無効になります。 |

### 基本的な操作:

| 操作 | 説明 | 例 |
|------|------|------|
| **生成** | 新しいベクトルを作成します。 | `std::vector<int> v;` |
| **初期化** | ベクトルを特定の値で初期化します。 | `std::vector<int> v(5, 10);` //サイズ5で全ての要素が10 |
| **push_back** | ベクトルの末尾に要素を追加します。 | `v.push_back(20);` |
| **pop_back** | ベクトルの末尾の要素を削除します。 | `v.pop_back();` |
| **at** | インデックスを指定して要素にアクセスします。 | `int x = v.at(2);` |
| **size** | ベクトルの要素数を返します。 | `size_t s = v.size();` |
| **capacity** | ベクトルが現在確保しているメモリの容量を返します。 | `size_t c = v.capacity();` |
| **empty** | ベクトルが空かどうかを確認します。 | `bool e = v.empty();` |
| **clear** | ベクトルの全要素を削除します。 | `v.clear();` |
| **insert** | 指定の位置に要素を挿入します。 | `v.insert(v.begin() + 2, 42);` // 3番目の位置に42を挿入 |
| **erase** | 指定の位置の要素を削除します。 | `v.erase(v.begin() + 2);` // 3番目の要素を削除 |
| **reserve** | メモリの容量を指定のサイズ以上に確保します。 | `v.reserve(100);` |
| **resize** | ベクトルのサイズを変更します。 | `v.resize(10);` //サイズを10に変更 |
| **swap** | 2つのベクトルの内容を交換します。 | `v1.swap(v2);` |

### 活用例

