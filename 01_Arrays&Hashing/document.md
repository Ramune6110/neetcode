# vector

### 基本概念と主な特徴:

| 項目 | 説明 |
|------|------|
| **基本概念** | `vector`は動的配列を表現するコンテナです。要素は連続したメモリ領域に格納されます。 |
| **順序** | 要素は挿入された順序で格納されます。 |
| **可変サイズ** | `vector`はサイズが動的であり、要素の追加や削除によりサイズが変更されます。 |
| **アクセス速度** | インデックスを使った要素へのアクセス（例：`vec[3]`）はO(1)の時間複雑度です。 |
| **挿入/削除速度** | 末尾への要素の挿入や削除は通常O(1)ですが、中央や先頭への挿入や削除はO(n)です。 |
| **メモリ** | 必要に応じてメモリを動的に確保します。予約 (`reserve()`) を使用してメモリの再確保を減少させることができます。 |
| **連続性** | メモリは連続しているため、ポインタやイテレータを使って要素にアクセスできます。 |
| **イテレータの無効化** | メモリの再確保が行われる場合（例：`push_back()`によるサイズの拡張時）、イテレータは無効になります。 |

### 基本的な操作:

| 操作 | 説明 | 例 |
|------|------|------|
| **生成** | 新しいベクトルを作成します。 | `std::vector<int> v;` |
| **初期化** | ベクトルを特定の値で初期化します。 | `std::vector<int> v(5, 10);` //サイズ5で全ての要素が10 |
| **push_back** | ベクトルの末尾に要素を追加します。 | `v.push_back(20);` |
| **pop_back** | ベクトルの末尾の要素を削除します。 | `v.pop_back();` |
| **at** | インデックスを指定して要素にアクセスします。 | `int x = v.at(2);` |
| **size** | ベクトルの要素数を返します。 | `size_t s = v.size();` |
| **capacity** | ベクトルが現在確保しているメモリの容量を返します。 | `size_t c = v.capacity();` |
| **empty** | ベクトルが空かどうかを確認します。 | `bool e = v.empty();` |
| **clear** | ベクトルの全要素を削除します。 | `v.clear();` |
| **insert** | 指定の位置に要素を挿入します。 | `v.insert(v.begin() + 2, 42);` // 3番目の位置に42を挿入 |
| **erase** | 指定の位置の要素を削除します。 | `v.erase(v.begin() + 2);` // 3番目の要素を削除 |
| **reserve** | メモリの容量を指定のサイズ以上に確保します。 | `v.reserve(100);` |
| **resize** | ベクトルのサイズを変更します。 | `v.resize(10);` //サイズを10に変更 |
| **swap** | 2つのベクトルの内容を交換します。 | `v1.swap(v2);` |

# unordered_set

### 基本概念と主な特徴:

| 項目 | 説明 |
|------|------|
| **基本概念** | `unordered_set`は、重複する要素を持たない集合を表現するコンテナです。 |
| **順序** | 要素は特定の順序で格納されず、ハッシュテーブルに基づいて内部で格納されます。 |
| **ユニーク性** | すべての要素はユニークであるため、同じ値を持つ要素は1つしか含まれません。 |
| **検索速度** | 要素の検索は平均的にO(1)の時間複雑度で、最悪の場合でもO(n)です。 |
| **挿入/削除速度** | 要素の挿入や削除も平均的にO(1)の時間複雑度で行えます。 |
| **ハッシュ関数** | 要素のハッシュ値を計算するためのハッシュ関数をカスタマイズすることができます。 |
| **メモリ** | 順序付きのセット(`std::set`)に比べて、少しメモリ使用量が多くなる可能性があります。 |
| **イテレータの無効化** | 要素の挿入や削除により、イテレータが無効になることはありません（ただし、ハッシュテーブルが再ハッシュされる場合を除く）。 |

### 基本的な操作:

| 操作 | 説明 | 例 |
|------|------|----|
| **初期化** | `unordered_set`を初期化する。 | `std::unordered_set<int> s;` |
| **挿入** | 要素をセットに追加する。 | `s.insert(4);` |
| **削除** | セットから要素を削除する。 | `s.erase(4);` |
| **検索** | 要素がセット内に存在するかどうかを確認する。 | `if(s.find(4) != s.end()) { /* found */ }` |
| **サイズ取得** | セットの要素数を返す。 | `int size = s.size();` |
| **空の確認** | セットが空であるかを確認する。 | `if(s.empty()) { /* empty */ }` |
| **全要素削除** | セットのすべての要素を削除する。 | `s.clear();` |

# unordered_map
1. 基本概念:
unordered_map は、C++のSTL(Standard Template Library)に含まれるコンテナの一つです。
キーと値のペアを保存することができるデータ構造です。
名前に "unordered" がついているのは、このマップ内の要素が特定の順序で保存されないことを示しています。

2. 主な特徴:
キーに基づいてアクセス: 各要素はキーと値のペアとして保存され、キーを使って素早くその要素にアクセスできます。
重複キーは許可されない: 同じキーで複数の要素を保存することはできません。
高速な検索: キーを使用して、要素を高速に検索することができます。

3. 基本的な操作:
要素の追加: mp[key] = value; または mp.insert({key, value});
要素の検索: mp.find(key) で、キーがマップに存在するかどうかを確認できます。
要素のアクセス: mp[key] で、キーに関連付けられた値にアクセスできます。
要素の削除: mp.erase(key) で、特定のキーを持つ要素を削除できます。