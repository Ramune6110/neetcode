# stack

### 基本概念と主な特徴:

| 項目 | 説明 |
|------|------|
| **基本概念** | `stack`はデータ構造の一つで、要素には「後入れ先出し」(Last In First Out, LIFO) の原則に従ってアクセスする。つまり、最後に追加された要素が最初に取り出される。 |
| **要素へのアクセス** | スタック上の最上部の要素のみにアクセスが可能。下にある要素に直接アクセスすることはできない。 |
| **要素の追加・削除** | 要素の追加（プッシュ）や削除（ポップ）はスタックの最上部でのみ行われる。 |
| **イテレーション** | `stack`はイテレーション（繰り返し処理）を直接サポートしていない。これは、`stack`がLIFO原則に基づいて設計されているため。 |
| **内部実装** | `stack`は実際にはコンテナアダプタとして実装されており、内部実装として`deque`や`vector`などの他のコンテナを使用している。しかし、その実装の詳細は通常の使用時には気にする必要はない。 |
| **パフォーマンス** | `stack`のデータの追加や削除は高速である。特に、内部で`deque`を使用している場合は、要素の追加や削除が定数時間で行われる。 |

### 基本的な操作:

| 操作 | 説明 | 例 |
|------|------|-----|
| `push()` | スタックの最上部に要素を追加する。 | `s.push(5);` |
| `pop()` | スタックの最上部の要素を削除する。要素の値を返すわけではないので注意。 | `s.pop();` |
| `top()` | スタックの最上部の要素を参照する。この操作で要素は削除されない。 | `int x = s.top();` |
| `empty()` | スタックが空かどうかをチェックする。空の場合は`true`、それ以外は`false`を返す。 | `if (s.empty()) {...}` |
| `size()` | スタックに格納されている要素の数を返す。 | `int n = s.size();` |
